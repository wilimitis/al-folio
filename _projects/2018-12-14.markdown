---
layout: page
title: indirect illumination i
description:
img: /assets/img/2018-12-14-project-1.png
---

<div class="img_row">
  <img class="col" src="{{ site.baseurl }}/assets/img/2018-12-14-project-3.png">
</div>
<div class="caption">
  ray traced Blinn-Phong 8 SPP
</div>

<div class="img_row">
  <img class="col" src="{{ site.baseurl }}/assets/img/2018-12-14-project-2.png">
</div>
<div class="caption">
  Monte Carlo indirect illumination 8 SPP, 1 direct sample, 16 indirect samples
</div>

<div class="img_row">
  <img class="col" src="{{ site.baseurl }}/assets/img/2018-12-14-project-1.png">
</div>
<div class="caption">
  Monte Carlo indirect illumination 8 SPP, 1 direct sample, 32 indirect samples
</div>

[source code](https://github.com/wilimitis/tracer)

A first pass at implementing indirect illumination by toying with some of the mathematical machinery introduced in _FoCG_.

The code approximates a solution to the rendering equation
```
Ls(ko) = âˆ« ğœŒ(ki, ko) Lf(ki) cosğœƒi dğœi
```

where
```
âˆ« = integral over all directions ki
Ls(ko) = reflected radiance at a point on a surface in direction ko
ğœŒ(ki, ko) = BRDF of directions ki and ko
Lf(ki) = field radiance of direction ki
cosğœƒi = cosine of ki and the surface normal
dğœi = change in solid angle at x
```

Taking a single sample
```
Ls(ko) â‰ˆ Le(ko) + ğœŒ(ki, ko) Lf(ki) cosğœƒi / p(ki)
```

where according to the following assumptions introduced in _FoCG_
```
ğœŒ(ki, ko) = 1 / ğœ‹
Lf(ki) = Ls(-ki)
p(ki) = cosğœƒi / ğœ‹
```

we arrive at
```
Ls(ko) â‰ˆ Le(ko) + Ls(-ki)
```

We can construct an efficient diffuse-only approach which samples direct lighting and indirect lighting. In the following code the contribution from a single point light is considered.
```
Color direct = pointLight.intensity * hit.normal.dot(-pointLight.direction(hit.point));
Color indirect;
for (int i = 0; i < INDIRECT_SAMPLES; i++) {
  Ray ray = sample(hit.normal, random(), random());
  indirect += color(ray);
}
indirect /= INDIRECT_SAMPLES;
return (direct + indirect) * diffuse;
```

In working out the math behind how a direct light sample is calculated, I realized an interesting relationship exists when evaluating the direct light sample according to the rendering equation integrated over surface area.
```
Ls(x, ko) = âˆ« ğœŒ(x, ki, ko) Ls(x', x - x') cosğœƒi cosğœƒ' dA / â€–x - x'â€–Â²
```

Taking a single sample
```
Ls(x, ko) â‰ˆ ğœŒ(x, ki, ko) Ls(x', x - x') cosğœƒi cosğœƒ' dA / (p(x') â€–x - x'â€–Â²)
```

Since _cosğœƒi_ is, in this case, the cosine of the angle between the surface normal and the direction from _x_ to the light, it is equivalent to the Lambertian term.
```
hit.normal.dot(-pointLight.direction(hit.point))
```

Taking a single sample where a ray cast from the surface at _x_ intersects a point light at _x'_
```
Ls(x', x - x') = Le(x', x - x')
ğœƒ' = 0 â‡’ cosğœƒ' = 1
cosğœƒi = n âˆ™ (x - x')
p(x') = 1 / A = 1
Ls(x, ko) â‰ˆ ğœŒ(x, ki, ko) Le(x', x - x') (n âˆ™ (x - x')) / â€–x - x'â€–Â²
```

Revealing that implementing a _1 / lengthÂ²_ falloff in the code above for the direct light sample would improve physical accuracy.

There's seemingly endless depth in every facet of this equation, and I can't wait to dive deeper!
